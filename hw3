#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <stdbool.h>
#include <ctype.h>
#include <math.h>
typedef struct Node {
    char data;
    int height;
    struct Node* left;
    struct Node* right;
} Node;
#define MAX_STACK_SIZE 100
void trim(char str[]) {
    for (int i = 0; i < strlen(str); i++) {
        if (isspace(str[i])) {
            for (int j = i; j < strlen(str); j++) {
                str[j] = str[j + 1];
            }
            i--;
        }
    }
}
Node* create_node(char data) {
    Node* newnode = (Node*)malloc(sizeof(Node));
    newnode->data = data;
    newnode->left = NULL;
    newnode->right = NULL;
    return newnode;
}
Node* newnode() {
    Node* newnode = (Node*)malloc(sizeof(Node));
    newnode->data = 0;
    newnode->left = NULL;
    newnode->right = NULL;
    return newnode;
}
Node* find_node(char data, Node* root) {
    if (root == NULL) return NULL;
    if (root->data == data) return root;
    Node* found = find_node(data, root->left);
    if (found != NULL) return found;
    return find_node(data, root->right);
}
Node* make_tree(char tree[]) {
    Node* root = newnode();
    for (int i = 0; i < strlen(tree); i++) {
        if (isalpha(tree[i]) && tree[i + 1] == '(') {
            Node* parent_node;
            if (root->data == 0) {
                root->data = tree[i];
                parent_node = root;
            }
            else {
                parent_node = find_node(tree[i], root);
            }

            if (parent_node != NULL) {
                int par_count = 0;
                for (int j = i + 2; j < strlen(tree); j++) {
                    if (tree[j] == '(')
                        par_count++;
                    else if (tree[j] == ')') {
                        if (par_count == 0) break;
                        par_count--;
                    }

                    if (isalpha(tree[j]) && par_count == 0) {
                        if (parent_node->left == NULL) {
                            parent_node->left = create_node(tree[j]);
                        }
                        else {
                            parent_node->right = create_node(tree[j]);
                        }
                    }
                }
            }
        }
    }
    return root;
}

int max_height(char tree[]) {
    int max_height = -1, height = -1;
    for (int i = 0; i < strlen(tree); i++) {
        if (tree[i] == '(') height++;
        else if (tree[i] == ')') height--;

        if (height >= max_height) max_height = height;
    }
    return max_height;
}
void fill_array(Node* root, char* arr, int index, int size) {
    if (root == NULL || index >= size) return;
    arr[index] = root->data;
    fill_array(root->left, arr, index * 2, size);
    fill_array(root->right, arr, index * 2 + 1, size);
}

char* make_array(char tree[]) {
    Node* binary_tree = make_tree(tree);
    int height = max_height(tree);
    int size = (int)pow(2, height + 1);

    char* arr = (char*)malloc(sizeof(char) * size);
    for (int i = 0; i < size; i++) arr[i] = '\0';

    fill_array(binary_tree, arr, 1, size);

    return arr;
}

struct Stack {
    int top;
    Node* items[MAX_STACK_SIZE];
};

void init_stack(struct Stack* s) {
    s->top = -1;
}

int is_stack_full(struct Stack* s) {
    return s->top == MAX_STACK_SIZE - 1;
}

int is_stack_empty(struct Stack* s) {
    return s->top == -1;
}

void push(struct Stack* s, Node* item) {
    if (is_stack_full(s)) {
        printf("Stack is full\n");
        return;
    }
    s->items[++s->top] = item;
}

Node* pop(struct Stack* s) {
    if (is_stack_empty(s)) {
        return NULL;
    }
    return s->items[s->top--];
}

void iterative_preorder(Node* root) {
    if (root == NULL) return;

    struct Stack stack;
    init_stack(&stack);
    push(&stack, root);

    printf("전위순회: ");
    while (!is_stack_empty(&stack)) {
        Node* node = pop(&stack);
        printf("%c ", node->data);

        if (node->right) {
            push(&stack, node->right);
        }
        if (node->left) {
            push(&stack, node->left);
        }
    }
    printf("\n");
}

void iterative_inorder(Node* root) {
    if (root == NULL) return;

    struct Stack stack;
    init_stack(&stack);
    Node* current = root;

    printf("중위순회: ");
    while (current != NULL || !is_stack_empty(&stack)) {
        while (current != NULL) {
            push(&stack, current);
            current = current->left;
        }

        current = pop(&stack);
        printf("%c ", current->data);

        current = current->right;
    }
    printf("\n");
}

void iterative_postorder(Node* root) {
    if (root == NULL) return;

    struct Stack s1, s2;
    init_stack(&s1);
    init_stack(&s2);

    push(&s1, root);

    while (!is_stack_empty(&s1)) {
        Node* node = pop(&s1);
        push(&s2, node);

        if (node->left) {
            push(&s1, node->left);
        }
        if (node->right) {
            push(&s1, node->right);
        }
    }

    printf("후위순회: ");
    while (!is_stack_empty(&s2)) {
        Node* node = pop(&s2);
        printf("%c ", node->data);
    }
    printf("\n");
}
int main() {
    char str[100];
    printf("input: ");
    scanf("%[^\n]s", str);
    trim(str);

    Node* root = make_tree(str);

    iterative_preorder(root);
    iterative_inorder(root);
    iterative_postorder(root);

    return 0;
}
